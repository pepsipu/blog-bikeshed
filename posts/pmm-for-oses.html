<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>the pepsi place | Writing a Physical Memory Manager for Operating Systems</title>
  <meta name="description" content="Implementing a circular double linked list kernel memory allocator for my latest operating system, dbOS.">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <meta property="og:title" content="Writing a Physical Memory Manager for Operating Systems">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://blog.pepsipu.com/posts/pmm-for-oses">
  <meta property="og:description" content="Implementing a circular double linked list kernel memory allocator for my latest operating system, dbOS.">
  <meta property="og:site_name" content="the pepsi place">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:url" content="https://blog.pepsipu.com/posts/pmm-for-oses">
  <meta name="twitter:title" content="Writing a Physical Memory Manager for Operating Systems">
  <meta name="twitter:description" content="Implementing a circular double linked list kernel memory allocator for my latest operating system, dbOS.">

  
    <meta property="og:image" content="https://blog.pepsipu.com/assets/og-image-04fbfc4e15efb2f7c4cde09b072db471162ce6a646dd0d04e1f19eec72491c9b.jpg">
    <meta name="twitter:image" content="https://blog.pepsipu.com/assets/og-image-04fbfc4e15efb2f7c4cde09b072db471162ce6a646dd0d04e1f19eec72491c9b.jpg">
  

  <link href="https://blog.pepsipu.com/feed.xml" type="application/rss+xml" rel="alternate" title="the pepsi place Last 10 blog posts" />

  

  

    
      <link rel="icon" type="image/x-icon" href="/assets/favicon-dark-11327753546b2135c989eee5cd83497a2734b702928d016839d795f6c706e3d5.ico">
      <link rel="apple-touch-icon" href="/assets/apple-touch-icon-dark-d161409442b7e523089f24d08d0a55951549ece7504207c376d53b020713494d.png">
      <link rel="stylesheet" type="text/css" href="/assets/dark-831218bc9e41aef39ee6a0bae4501195bccafcc13101ae2b9cd20493a6ec04c0.css">
    

  

</head>

<body>
  <main>
    <div class="grid grid-centered">
      <div class="grid-cell">
        <nav class="header-nav scrollappear">
  <a href="/" class="header-logo" title="the pepsi place">the pepsi place</a>
  <ul class="header-links">
    
    
    
    
    
      <li>
        <a href="https://github.com/pepsipu" rel="noreferrer noopener" target="_blank" title="GitHub">
          <svg xmlns="http://www.w3.org/2000/svg" class="icon-github">
  <use href="/assets/github-094f81040819f34343ee6ffff0980f17e2807b08b595eaaf66ae3554934fd78d.svg#icon-github" xlink:href="/assets/github-094f81040819f34343ee6ffff0980f17e2807b08b595eaaf66ae3554934fd78d.svg#icon-github"></use>
</svg>

        </a>
      </li>
    
    
    
    
    
    
    
    
    
    
      <li>
        <a href="https://instagram.com/sam.hajhamid" rel="noreferrer noopener" target="_blank" title="Instagram">
          <svg xmlns="http://www.w3.org/2000/svg" class="icon-instagram">
  <use href="/assets/instagram-37f85bc75b43ecc4c114d9a46f846327fe13c5893787c6afbcfef9d30d58bd9e.svg#icon-instagram" xlink:href="/assets/instagram-37f85bc75b43ecc4c114d9a46f846327fe13c5893787c6afbcfef9d30d58bd9e.svg#icon-instagram"></use>
</svg>

        </a>
      </li>
    
    
    
    
    
    
    
    
    
    
      <li>
        <a href="mailto:pepsipu@pepsipu.com" title="Email">
          <svg xmlns="http://www.w3.org/2000/svg" class="icon-email">
  <use href="/assets/email-782473193bf750036fdb90e8daa075508a20509d01854c09f3237c144a3f0601.svg#icon-email" xlink:href="/assets/email-782473193bf750036fdb90e8daa075508a20509d01854c09f3237c144a3f0601.svg#icon-email"></use>
</svg>

        </a>
      </li>
    
    
      <li>
        <a href="/feed.xml" rel="noreferrer noopener" target="_blank" title="RSS">
          <svg xmlns="http://www.w3.org/2000/svg" class="icon-rss">
  <use href="/assets/rss-541ec5cea9cefd10d2fcfec01888f3f231a8829940249835fa7b7b3a12ae0d0d.svg#icon-rss" xlink:href="/assets/rss-541ec5cea9cefd10d2fcfec01888f3f231a8829940249835fa7b7b3a12ae0d0d.svg#icon-rss"></use>
</svg>

        </a>
      </li>
    
    
  </ul>
</nav>



        <article class="article scrollappear">
          <header class="article-header">
            <h1>Writing a Physical Memory Manager for Operating Systems</h1>
            <p>Implementing a circular double linked list kernel memory allocator for my latest operating system, dbOS.</p>
            <div class="article-list-footer">
  <span class="article-list-date">
    June 13, 2020
  </span>
  <span class="article-list-divider">-</span>
  <div class="article-list-tags">
    
      
      <a href="/tag/kmalloc" title="See all posts with tag ''"></a>
    
      
      <a href="/tag/heap" title="See all posts with tag ''"></a>
    
      
      <a href="/tag/pmm" title="See all posts with tag ''"></a>
    
  </div>
</div>
          </header>

          <div class="article-content">
            <p><code class="highlighter-rouge">malloc</code> and <code class="highlighter-rouge">free</code>. The two most essential functions to dynamic memory in userland. <code class="highlighter-rouge">malloc</code> provides chunks of memory to the program of the request size, no questions asked. The only requirement is, when you finish using the chunk, you return it to the allocator with <code class="highlighter-rouge">free</code>. It’s not very important to most C developers how the internals of both of these functions work, and even less important on how the counter parts of these functions, <code class="highlighter-rouge">kmalloc</code> and <code class="highlighter-rouge">kfree</code> work in ring 0, kernel land. But, when it comes time to write your own operating system, it’s imperative you understand how <code class="highlighter-rouge">kmalloc</code> makes physical memory available to internal routines in ring 0.</p>

<p>Physical memory is a different beast entirely when compared to the virtual memory that programs in userland utilize. <code class="highlighter-rouge">malloc</code> and <code class="highlighter-rouge">free</code> simply “request” virtual memory from the kernel and don’t need to worry about the physical memory that the virtual memory maps to. Now we are writing our own physical memory allocator, we should discuss memory maps.</p>

<h2 id="memory-maps">Memory Maps</h2>
<p>Memory maps provide a way for operating systems to know the layout of RAM. For example, memory maps allow the operating system to know where memory mapped peripherals, regions for free use, reserved regions, and bad/faulty memory is located. Though, how does an operating system obtain a memory map?</p>

<h3 id="creating-a-memory-map">Creating a Memory Map</h3>
<p>Routines made available by the BIOS can be used to obtain information about the memory. The biggest things we will need to know are the upper bound of the memory and the lower bound of the memory.</p>

<h4 id="lower-memory-bound">Lower Memory Bound</h4>
<p>Although it’s assumed that address <code class="highlighter-rouge">0x0</code> should be the first memory address, it’s extremely discouraged to use it. The BIOS uses a special interrupt table stored at address 0 called the interrupt vector table which handles software and hardware interrupts. If you use address 0, or any memory near to it for that matter, you’ll end up smashing the IVT. So, how to do we get the lowest address in memory that the BIOS doesn’t use?</p>

<p>To fetch the lower bound of available memory, you can call upon the BIOS to help you out. Software interrupt 0x12 will load register <code class="highlighter-rouge">AX</code> with the amount of KB away from address 0 the first available address is. Our assembly code would look a little something like this:</p>

<pre><code class="language-asm">int 0x12
; AX * 1024 will be the address
</code></pre>

<h4 id="upper-memory-bound">Upper Memory Bound</h4>
<p>Getting the upper memory bound is slightly more complicated. Since, as you know, physical memory is not linear and has several memory regions which are unavailable for use, getting a clear “upper bound” is not really possible.</p>

<p>Thankfully, the BIOS has us covered again. By raising software interrupt 0x15, as well as setting <code class="highlighter-rouge">EAX</code> to <code class="highlighter-rouge">0xe820</code>, we can get a region and it’s properties provided by the BIOS.</p>

<p>On raising the interrupt, <code class="highlighter-rouge">ES:DI</code> will be used as the pointer to the buffer and <code class="highlighter-rouge">ECX</code> will be how many bytes to read from the memory map to the buffer.</p>

<p><code class="highlighter-rouge">EBX</code> has a very special role in this interrupt. It is used as the “Continuation” value. Since you can only retrieve one region’s information from the BIOS, <code class="highlighter-rouge">EBX</code> contains what is essentially a pointer to the next entry in the memory map.</p>

<p>The 0x15 interrupt is raised once per entry. Raising it 10 times will get you 10 entries.</p>

<p>From what I could get off of the 1996 GRUB specification, the entries are structured as so:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">mmap_entry</span> <span class="p">{</span>
    <span class="kt">uint64_t</span> <span class="n">start_address</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">length</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">type</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">type</code> will tell you about the region. There are different types of memory regions, but for now, you should know that a type of <code class="highlighter-rouge">1</code> will mean the region is free.</p>

<h2 id="writing-a-memory-allocator-which-uses-memory-that-spans-multiple-non-contiguous-regions">Writing a memory allocator which uses memory that spans multiple non-contiguous regions</h2>

<h3 id="initialization">Initialization</h3>
<p>In userland, thanks to the magic of virtual memory, memory is almost always linear in the heap. This means that when you request more memory from the operating system, the new memory will be adjacent to the rest of the memory on the heap. We don’t have these luxuries in kernel space, so we will need to make sure our allocator takes into consideration multiple regions.</p>

<p>This isn’t as difficult as it sounds. The main thing we need to do to accommodate this change is include metadata about each region in some sort of list.</p>

<p>Let’s make a structure that will keep tabs on each region of memory.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">len</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">used</span><span class="p">;</span>
<span class="p">}</span> <span class="n">region_state_t</span><span class="p">;</span>
</code></pre></div></div>
<p>This information needs to be stored for each region, so I’ll make a global variable that points to an array of <code class="highlighter-rouge">region_state_t</code> and another variable that holds the amount of elements in that array.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">region_state_t</span> <span class="o">*</span><span class="n">fm_regions</span><span class="p">;</span>
<span class="kt">uint32_t</span> <span class="n">fm_region_len</span><span class="p">;</span>
</code></pre></div></div>

<p>We can use the memory map from before to find free regions and store those regions in an array. Since we don’t have a heap yet, we can use a dynamically allocated stack array until we do get a heap.</p>

<p>Our init function for our physical memory manager would need to do find each free region, which has a type of one, and add it to the stack array. This is done like so:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// in function void init_pmm(multiboot_memory_map_t *mmap_addr, uint32_t mmap_length);</span>
<span class="n">multiboot_memory_map_t</span> <span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="n">mmap_addr</span><span class="p">;</span>
<span class="c1">// use dynamic stack array because we don't have heap yet</span>
<span class="n">multiboot_memory_map_t</span> <span class="o">*</span><span class="n">free_memory_region</span><span class="p">[</span><span class="n">mmap_length</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">multiboot_memory_map_t</span><span class="p">)];</span>
<span class="kt">int</span> <span class="n">free_memory_count</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="n">free_memory_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">mmap_addr</span> <span class="o">+</span> <span class="n">mmap_length</span> <span class="o">&gt;</span> <span class="n">entry</span><span class="p">;)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">free_memory_region</span><span class="p">[</span><span class="n">free_memory_count</span><span class="p">]</span> <span class="o">=</span> <span class="n">entry</span><span class="p">;</span>
        <span class="o">++</span><span class="n">free_memory_count</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">entry</span> <span class="o">=</span> <span class="p">(</span><span class="n">multiboot_memory_map_t</span> <span class="o">*</span><span class="p">)((</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">entry</span> <span class="o">+</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Here, we cycle through each entry of the memory map (which GRUB provides us through the methods mentioned before) and specifically save the regions which have a type of one, meaning it is marked as available memory.</p>

<p>Now, we need to find a memory region to store our metadata about all the regions. We can’t keep using a stack array, since that won’t last outside the initialization function. To do this, we simply cycle through each region, looking for a region large enough to house the metadata. Once we find a region like that, we move information from the stack array to the new array in the region. Then, we can shrink the region by the size of the metadata array, so we can use the rest of the region without modifying the metadata.</p>

<p>We can do this like so:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fm_region_len</span> <span class="o">=</span> <span class="n">free_memory_count</span><span class="p">;</span>
<span class="c1">// find region who can store metadata</span>
<span class="kt">int</span> <span class="n">metadata_chunk_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">size_t</span> <span class="n">size_needed</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">region_state_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">fm_region_len</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">metadata_chunk_index</span> <span class="o">&lt;</span> <span class="n">fm_region_len</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">multiboot_memory_map_t</span> <span class="o">*</span><span class="n">region</span> <span class="o">=</span> <span class="n">free_memory_region</span><span class="p">[</span><span class="n">metadata_chunk_index</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">region</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">size_needed</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">fm_regions</span> <span class="o">=</span> <span class="n">region</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span>
        <span class="c1">// shift over usable memory so we dont overwrite the region metadata</span>
        <span class="n">region</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">+=</span> <span class="n">size_needed</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">fm_region_len</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">region_state_t</span> <span class="o">*</span><span class="n">new_region</span> <span class="o">=</span> <span class="n">fm_regions</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">region_state_t</span><span class="p">);</span>
            <span class="o">*</span><span class="n">new_region</span> <span class="o">=</span> <span class="p">(</span><span class="n">region_state_t</span><span class="p">){</span>
                <span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="n">region</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span>
                <span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">region</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
                <span class="p">.</span><span class="n">used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
            <span class="p">};</span>
        <span class="p">}</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="o">++</span><span class="n">metadata_chunk_index</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now that we’ve saved all our information about the regions into an array in one of the regions, we can finally use this data in our <code class="highlighter-rouge">kmalloc</code> and <code class="highlighter-rouge">kfree</code> functions.</p>
<h3 id="chunk-structures">Chunk Structures</h3>
<p>First, let’s define a structure of an allocated chunk.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">data</span><span class="p">[];</span>
<span class="p">}</span> <span class="n">allocated_chunk_t</span><span class="p">;</span>
</code></pre></div></div>
<p>All it’ll contain is the size of the chunk and user data after it. Pretty simple, right?</p>

<p>Now, we need to define how our freed chunks are going to look like.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">free_chunk</span>
<span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">free_chunk</span> <span class="o">*</span><span class="n">fd</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">free_chunk</span> <span class="o">*</span><span class="n">bk</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">free_chunk</span> <span class="n">free_chunk_t</span><span class="p">;</span>
</code></pre></div></div>
<p>It’s the same as the allocated chunk, but where the data once was, we now have forward and backward pointers for our double linked list. The forward pointer will point to the next free chunk, and the backward pointer will point to the freed chunk before it.</p>

<p>I’m also going to make a global variable called <code class="highlighter-rouge">free_bin</code>, which will contain the forward and backward starting pointers for the free chunks.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">free_chunk_t</span> <span class="n">free_bin</span> <span class="o">=</span> <span class="p">(</span><span class="n">free_chunk_t</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">free_bin</span><span class="p">,</span>
    <span class="p">.</span><span class="n">bk</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">free_bin</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div></div>
<p>Since this is a circularly linked list, it’s forward and backward pointers are going to be itself.</p>
<h2 id="kmalloc">kmalloc</h2>
<p><code class="highlighter-rouge">kmalloc</code> is going to be the function that the kernel will be calling when it needs memory.</p>

<p>First, we should define the order of which <code class="highlighter-rouge">kmalloc</code> will look for free memory. The first thing it should do is search through the list of free chunks, looking for a free chunk which is exactly the size of the requested chunk. If it is, we can just return the free chunk. If the free chunk is bigger, we can split the chunk into two chunks and return the one that is the request size. If we can’t find a free chunk like that, we can simply use a region’s memory. Let’s implement that in code.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="o">*</span><span class="nf">kmalloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">requested_size</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">requested_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="c1">// round to nearest multiple of 8 so we get alignment</span>
    <span class="kt">size_t</span> <span class="n">aligned_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">requested_size</span>  <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">allocated_chunk_t</span><span class="p">)</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">-</span><span class="mi">8</span><span class="p">;</span>
    <span class="c1">// ensure size is big enough to fit a free chunk</span>
    <span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">aligned_size</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">free_chunk_t</span><span class="p">)</span> <span class="o">?</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">free_chunk_t</span><span class="p">)</span> <span class="o">:</span> <span class="n">aligned_size</span><span class="p">;</span>
    <span class="n">free_chunk_t</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">free_bin</span><span class="p">.</span><span class="n">fd</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">free_bin</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">==</span> <span class="n">size</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="c1">// unlink from free list</span>
                <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">bk</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">;</span>
                <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">fd</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">bk</span><span class="p">;</span>
                <span class="k">return</span> <span class="n">ptr</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">allocated_chunk_t</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="c1">// ensure we can split chunk and still have space for a free chunk</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">size</span> <span class="o">&amp;&amp;</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="n">size</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">allocated_chunk_t</span><span class="p">)</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">free_chunk_t</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-=</span> <span class="n">size</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">allocated_chunk_t</span><span class="p">);</span>
                <span class="n">allocated_chunk_t</span> <span class="o">*</span><span class="n">new_chunk</span> <span class="o">=</span> <span class="n">ptr</span> <span class="o">+</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">allocated_chunk_t</span><span class="p">);</span>
                <span class="n">new_chunk</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="c1">// if we can't find a free chunk, we can make a new chunk from the memory regions</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">fm_region_len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">region_state_t</span> <span class="o">*</span><span class="n">region</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fm_regions</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">region</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">region</span><span class="o">-&gt;</span><span class="n">used</span> <span class="o">&gt;</span> <span class="n">size</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">allocated_chunk_t</span> <span class="o">*</span><span class="n">new_chunk</span> <span class="o">=</span> <span class="n">region</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">+</span> <span class="n">region</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">;</span>
            <span class="n">new_chunk</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
            <span class="n">region</span><span class="o">-&gt;</span><span class="n">used</span> <span class="o">+=</span> <span class="n">size</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">allocated_chunk_t</span><span class="p">);</span>
            <span class="k">return</span> <span class="o">&amp;</span><span class="n">new_chunk</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// uh oh</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="kfree">kfree</h2>
<p><code class="highlighter-rouge">kfree</code> is pretty easy to implement. All we have to do is add the given chunk to the free list. We insert at the start of the list, changing <code class="highlighter-rouge">free_bin</code>’s forward and backward pointers.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">kfree</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">chunk</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">free_chunk_t</span> <span class="o">*</span><span class="n">chunk_to_free</span> <span class="o">=</span> <span class="n">chunk</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">allocated_chunk_t</span><span class="p">);</span>
    <span class="c1">// link chunk to free list</span>
    <span class="n">chunk_to_free</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">free_bin</span><span class="p">.</span><span class="n">fd</span><span class="o">-&gt;</span><span class="n">bk</span><span class="p">;</span>
    <span class="n">free_bin</span><span class="p">.</span><span class="n">fd</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">chunk_to_free</span><span class="p">;</span>
    <span class="n">chunk_to_free</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">free_bin</span><span class="p">.</span><span class="n">fd</span><span class="p">;</span>
    <span class="n">free_bin</span><span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="n">chunk_to_free</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

          </div>
          <div class="article-share">
            
            
            <a href="https://twitter.com/home?status=Writing+a+Physical+Memory+Manager+for+Operating+Systems%20-%20https://blog.pepsipu.com/posts/pmm-for-oses" title="Share on Twitter" rel="noreferrer noopener" target="_blank">
              <svg viewBox="0 0 512 512"><path d="M492 109.5c-17.4 7.7-36 12.9-55.6 15.3 20-12 35.4-31 42.6-53.6 -18.7 11.1-39.4 19.2-61.5 23.5C399.8 75.8 374.6 64 346.8 64c-53.5 0-96.8 43.4-96.8 96.9 0 7.6 0.8 15 2.5 22.1 -80.5-4-151.9-42.6-199.6-101.3 -8.3 14.3-13.1 31-13.1 48.7 0 33.6 17.2 63.3 43.2 80.7C67 210.7 52 206.3 39 199c0 0.4 0 0.8 0 1.2 0 47 33.4 86.1 77.7 95 -8.1 2.2-16.7 3.4-25.5 3.4 -6.2 0-12.3-0.6-18.2-1.8 12.3 38.5 48.1 66.5 90.5 67.3 -33.1 26-74.9 41.5-120.3 41.5 -7.8 0-15.5-0.5-23.1-1.4C62.8 432 113.7 448 168.3 448 346.6 448 444 300.3 444 172.2c0-4.2-0.1-8.4-0.3-12.5C462.6 146 479 129 492 109.5z"/></svg>
            </a>
            <a href="https://www.facebook.com/sharer/sharer.php?u=https://blog.pepsipu.com/posts/pmm-for-oses" title="Share on Facebook" rel="noreferrer noopener" target="_blank">
              <svg viewBox="0 0 512 512"><path d="M288 192v-38.1c0-17.2 3.8-25.9 30.5-25.9H352V64h-55.9c-68.5 0-91.1 31.4-91.1 85.3V192h-45v64h45v192h83V256h56.4l7.6-64H288z"/></svg>
            </a>
          </div>

          
        </article>
        <footer class="footer scrollappear">
  <p>
    sponsored by subpar blue: terrorizing tcaches since 2017
  </p>
</footer>

      </div>
    </div>
  </main>
  
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-XQXDK9JQPD"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-XQXDK9JQPD');
  </script>


<script type="text/javascript" src="/assets/vendor-3ee2c63bbac916f96cd7f90e83ab767f058ead1301444c9966f5156911c8be7f.js"></script>


  <script type="text/javascript" src="/assets/webfonts-96493456d319d1bf419afdf8701552d4d486fee6afd304897d4fd81eb4e0cc0b.js"></script>



  <script type="text/javascript" src="/assets/scrollappear-e2da8ea567e418637e31266cc5302126eaa79f62a2273739086358b589a89ee6.js"></script>


<script type="text/javascript" src="/assets/application-cfde13ac81ddaf4351b2e739603e2baf688d0fcc9aba613fe62bbb1c7b037fb9.js"></script>


</body>
</html>
